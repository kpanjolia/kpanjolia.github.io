<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Netflix Top 10 During COVID</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Cambria Math', serif;
            margin: 0;
            padding: 20px;
            background-color: #0f0f0f;
            color: #ffffff;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #e50914;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            color: #999;
            font-size: 1.2em;
            margin-bottom: 40px;
        }

        .level-indicator {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.1em;
            color: #e50914;
        }

        #visualization {
            background-color: #1a1a1a;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .chart-title {
            text-align: center;
            font-size: 1.4em;
            margin-bottom: 20px;
            color: #fff;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #e50914;
            pointer-events: none;
            font-size: 12px;
            z-index: 1000;
        }

        .axis {
            font-size: 12px;
            fill: #ccc;
        }

        .axis-label {
            font-size: 14px;
            fill: #fff;
        }

        .loading {
            text-align: center;
            font-size: 1.2em;
            color: #999;
            margin: 50px 0;
        }

        .error {
            text-align: center;
            color: #e50914;
            font-size: 1.1em;
            margin: 50px 0;
        }

        .navigation {
            text-align: center;
            margin-top: 20px;
        }

        .nav-button {
            background-color: #e50914;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 0 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .nav-button:hover {
            background-color: #b20710;
        }

        .nav-button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }

        .nav-button.active {
            background-color: #b20710;
            box-shadow: 0 0 10px rgba(229, 9, 20, 0.5);
        }

        .show-selector {
            text-align: center;
            margin-bottom: 20px;
        }

        .show-selector select {
            background-color: #2a2a2a;
            color: white;
            border: 1px solid #666;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            margin: 0 10px;
        }

        .lifecycle-line {
            fill: none;
            stroke: #e50914;
            stroke-width: 3;
        }

        .lifecycle-point {
            fill: #e50914;
            stroke: #fff;
            stroke-width: 2;
        }

        .release-line {
            stroke: #00d4ff;
            stroke-width: 2;
            stroke-dasharray: 5,5;
        }

        .out-of-top10 {
            fill: #666;
            opacity: 0.5;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Netflix Top 10 During COVID</h1>
        <p class="subtitle">Daily Rankings of Movies and TV Shows in the US from March 31st, 2020 to March 10th, 2022</p>
        
        <div class="level-indicator">
            <span id="current-level">Level 1: The Streaming Landscape</span>
        </div>
        
        <div id="visualization">
            <div class="chart-title" id="chart-title">Loading Netflix data...</div>
            <div class="loading" id="loading">Fetching data from repository...</div>
        </div>
        
        <div class="navigation">
            <button class="nav-button active" id="level1-btn" disabled>Level 1</button>
            <button class="nav-button" id="level2-btn" disabled>Level 2</button>
            <button class="nav-button" id="level3-btn" disabled>Level 3</button>
            <button class="nav-button" id="reset-btn" disabled>Reset to Overview</button>
        </div>
    </div>

    <script>
        const config = {
            width: 1000,
            height: 600,
            margin: { top: 40, right: 80, bottom: 80, left: 80 },
            dataPath: "./data/netflix_daily_top_10.csv"
        };

        let rawData = [];
        let processedData = [];
        let currentLevel = 1;
        let svg, tooltip;

        function init() {
            setupSVG();
            setupTooltip();
            loadData();
            setupNavigation();
        }

        function setupSVG() {
            const container = d3.select("#visualization");
            
            svg = container.append("svg")
                .attr("width", config.width)
                .attr("height", config.height)
                .style("display", "block")
                .style("margin", "0 auto");

            // group for main chart area
            svg.append("g")
                .attr("class", "chart-area")
                .attr("transform", `translate(${config.margin.left},${config.margin.top})`);
        }

        function setupTooltip() {
            tooltip = d3.select("body")
                .append("div")
                .attr("class", "tooltip")
                .style("opacity", 0);
        }

        // load and process data
        async function loadData() {
            try {
                const data = await d3.csv(config.dataPath);
                
                if (!data || data.length === 0) {
                    showError("No data found. Please check your data file path.");
                    return;
                }

                rawData = data;
                processedData = processData(data);
                
                hideLoading();
                drawLevel1();
                enableNavigation();
                
            } catch (error) {
                console.error("Error loading data:", error);
                showError(`Error loading data: ${error.message}. Make sure your CSV file is accessible at: ${config.dataPath}`);
            }
        }

        // Process raw CSV data
        function processData(data) {
            return data.map(d => ({
                date: d3.timeParse("%Y-%m-%d")(d["As of"]), 
                title: d["Title"],
                rank: +d["Rank"],
                type: d["Type"],
                releaseDate: d3.timeParse("%b %e, %Y")(d["Netflix Release Date"]),
            })); 
        }

        // Level 1: Overview visualization
        let animationState = {
            isPlaying: false,
            currentDateIndex: 0,
            interval: null,
            speed: 50, // milliseconds per frame
            uniqueDates: [],
            dateData: new Map()
        };

        // Level 1: Animated Bump Chart visualization
        function drawLevel1() {
            updateLevelIndicator(1, "Level 1: The Streaming Landscape");
            updateChartTitle("Animated Top 10 Rankings Over Time");

            const chartArea = svg.select(".chart-area");
            chartArea.selectAll("*").remove(); // Clear previous content

            if (processedData.length === 0) {
                showError("No valid data to display");
                return;
            }

            // Prepare data for animation
            prepareAnimationData();
            
            // Set up scales
            const chartWidth = config.width - config.margin.left - config.margin.right;
            const chartHeight = config.height - config.margin.top - config.margin.bottom;
            
            const yScale = d3.scaleLinear()
                .domain([1, 10])
                .range([0, chartHeight]);

            const colorScale = d3.scaleOrdinal()
            .domain(['Movie', 'TV Show', 'Unknown'])
            .range(['#e50914', '#00d4ff', '#999999']);

            const legend = chartArea.append("g")
                .attr("class", "legend")
                .attr("transform", `translate(${chartWidth - 150}, 20)`);

            const legendData = [
                { type: 'Movie', color: '#e50914' },
                { type: 'TV Show', color: '#00d4ff' },
                { type: 'Unknown', color: '#999999' }
            ];

            const legendItems = legend.selectAll(".legend-item")
                .data(legendData)
                .enter()
                .append("g")
                .attr("class", "legend-item")
                .attr("transform", (d, i) => `translate(0, ${i * 20})`);

            legendItems.append("rect")
                .attr("width", 12)
                .attr("height", 12)
                .attr("fill", d => d.color);

            legendItems.append("text")
                .attr("x", 18)
                .attr("y", 6)
                .attr("dy", "0.35em")
                .style("fill", "#fff")
                .style("font-size", "12px")
                .text(d => d.type);

            // Add ranking labels (1-10)
            chartArea.selectAll(".rank-label")
                .data([1,2,3,4,5,6,7,8,9,10])
                .enter()
                .append("text")
                .attr("class", "rank-label")
                .attr("x", -10)
                .attr("y", d => yScale(d) + 5)
                .attr("text-anchor", "end")
                .style("fill", "#999")
                .style("font-size", "12px")
                .text(d => d);

            // Add title "Rank" label
            chartArea.append("text")
                .attr("class", "axis-label")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - config.margin.left + 20)
                .attr("x", 0 - chartHeight / 2)
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .style("fill", "#fff")
                .text("Rank");

            // Create animation controls
            createAnimationControls();
            
            // Draw initial frame
            drawBumpChartFrame(0, yScale, colorScale, chartWidth, chartHeight);
        }

        function prepareAnimationData() {
            // Get unique dates sorted
            animationState.uniqueDates = [...new Set(processedData.map(d => d.date))]
                .sort((a, b) => a - b);

            // Group data by date
            animationState.dateData = d3.group(processedData, d => d.date.getTime());
            
            // Fill in missing rankings for smooth animation
            animationState.uniqueDates.forEach(date => {
                const dateKey = date.getTime();
                const dayData = animationState.dateData.get(dateKey) || [];
                
                // Ensure we have exactly 10 entries for each date
                const rankedData = [];
                for (let rank = 1; rank <= 10; rank++) {
                    const entry = dayData.find(d => d.rank === rank);
                    if (entry) {
                        rankedData.push(entry);
                    } else {
                        // Fill with placeholder if no show at this rank
                        rankedData.push({
                            date: date,
                            title: `Rank ${rank}`,
                            rank: rank,
                            isPlaceholder: true
                        });
                    }
                }
                animationState.dateData.set(dateKey, rankedData);
            });
        }

        function createAnimationControls() {
            // Remove existing controls
            d3.select("#animation-controls").remove();
            
            // Add animation controls before the chart
            const controlsDiv = d3.select("#visualization")
                .insert("div", "svg")
                .attr("id", "animation-controls")
                .style("text-align", "center")
                .style("margin-bottom", "20px");

            // Current date display
            controlsDiv.append("div")
                .attr("id", "current-date")
                .style("font-size", "18px")
                .style("color", "#e50914")
                .style("margin-bottom", "10px")
                .text("March 2020");

            // Control buttons
            const buttonGroup = controlsDiv.append("div")
                .attr("id", "button-group");

            buttonGroup.append("button")
                .attr("id", "play-btn")
                .attr("class", "control-button")
                .style("background-color", "#e50914")
                .style("color", "white")
                .style("border", "none")
                .style("padding", "8px 16px")
                .style("margin", "0 5px")
                .style("border-radius", "4px")
                .style("cursor", "pointer")
                .text("▶ Play")
                .on("click", playAnimation);

            buttonGroup.append("button")
                .attr("id", "pause-btn")
                .attr("class", "control-button")
                .style("background-color", "#666")
                .style("color", "white")
                .style("border", "none")
                .style("padding", "8px 16px")
                .style("margin", "0 5px")
                .style("border-radius", "4px")
                .style("cursor", "pointer")
                .text("⏸ Pause")
                .on("click", pauseAnimation);

            buttonGroup.append("button")
                .attr("id", "stop-btn")
                .attr("class", "control-button")
                .style("background-color", "#666")
                .style("color", "white")
                .style("border", "none")
                .style("padding", "8px 16px")
                .style("margin", "0 5px")
                .style("border-radius", "4px")
                .style("cursor", "pointer")
                .text("⏹ Stop")
                .on("click", stopAnimation);

            buttonGroup.append("button")
                .attr("id", "reset-btn-anim")
                .attr("class", "control-button")
                .style("background-color", "#666")
                .style("color", "white")
                .style("border", "none")
                .style("padding", "8px 16px")
                .style("margin", "0 5px")
                .style("border-radius", "4px")
                .style("cursor", "pointer")
                .text("⏮ Reset")
                .on("click", resetAnimation);
        }

        function drawBumpChartFrame(dateIndex, yScale, colorScale, chartWidth, chartHeight) {
            const currentDate = animationState.uniqueDates[dateIndex];
            const currentData = animationState.dateData.get(currentDate.getTime()) || [];
            
            // Update date display
            d3.select("#current-date")
                .text(d3.timeFormat("%B %Y")(currentDate));

            const chartArea = svg.select(".chart-area");
            
            // First, draw static ranking background stripes if not already drawn
            if (chartArea.selectAll(".rank-bg").empty()) {
                chartArea.selectAll(".rank-bg")
                    .data([1,2,3,4,5,6,7,8,9,10])
                    .enter()
                    .append("rect")
                    .attr("class", "rank-bg")
                    .attr("x", 0)
                    .attr("y", d => yScale(d))
                    .attr("width", chartWidth)
                    .attr("height", chartHeight / 10 - 2)
                    .attr("fill", (d, i) => i % 2 === 0 ? "#2a2a2a" : "#1f1f1f")
                    .attr("opacity", 0.3);
            }
            
            // Bind data to show elements using title as key for continuity
            const shows = chartArea.selectAll(".show-element")
                .data(currentData.filter(d => !d.isPlaceholder), d => d.title);

            // Enter new shows
            const showEnter = shows.enter()
                .append("g")
                .attr("class", "show-element")
                .attr("transform", d => `translate(0, ${yScale(d.rank)})`);

            // Add colored bars for new shows
            showEnter.append("rect")
                .attr("class", "show-bar")
                .attr("x", 0)
                .attr("y", 2)
                .attr("height", chartHeight / 10 - 4)
                .attr("width", 0) // Start with 0 width for smooth entry
                .attr("fill", d => colorScale(d.type))
                .attr("opacity", 0.8)
                .transition()
                .duration(300)
                .attr("width", Math.max(100, chartWidth * 0.7));

            // Add title text for new shows
            showEnter.append("text")
                .attr("class", "show-title")
                .attr("x", 10)
                .attr("y", (chartHeight / 10) / 2)
                .attr("dy", "0.35em")
                .style("fill", "white")
                .style("font-size", "14px")
                .style("font-weight", "bold")
                .style("opacity", 0)
                .text(d => d.title.length > 30 ? d.title.substring(0, 30) + "..." : d.title)
                .transition()
                .duration(300)
                .style("opacity", 1);

            // Add rank number for new shows
            showEnter.append("text")
                .attr("class", "show-rank")
                .attr("x", chartWidth - 10)
                .attr("y", (chartHeight / 10) / 2)
                .attr("text-anchor", "end")
                .attr("dy", "0.35em")
                .style("fill", "#999")
                .style("font-size", "12px")
                .style("opacity", 0)
                .text(d => `#${d.rank}`)
                .transition()
                .duration(300)
                .style("opacity", 1);

            // Update existing shows - this is the key part for movement
            const showUpdate = showEnter.merge(shows);

            // Animate position changes - this creates the racing effect
            showUpdate.transition()
                .duration(animationState.isPlaying ? animationState.speed * 0.8 : 0)
                .ease(d3.easeLinear)
                .attr("transform", d => `translate(0, ${yScale(d.rank)})`);

            // Update rank text
            showUpdate.select(".show-rank")
                .transition()
                .duration(animationState.isPlaying ? animationState.speed * 0.4 : 0)
                .tween("text", function(d) {
                    const currentText = d3.select(this).text();
                    const currentRank = parseInt(currentText.replace('#', '')) || d.rank;
                    const interpolate = d3.interpolateNumber(currentRank, d.rank);
                    return function(t) {
                        d3.select(this).text(`#${Math.round(interpolate(t))}`);
                    };
                });

            // Update bar colors (in case show changes)
            showUpdate.select(".show-bar")
                .transition()
                .duration(animationState.isPlaying ? animationState.speed * 0.4 : 0)
                .attr("fill", d => colorScale(d.type));

            // Handle exiting shows (fade out)
            shows.exit()
                .transition()
                .duration(300)
                .style("opacity", 0)
                .remove();

            // Add interaction to show elements
            showUpdate
                .style("cursor", "pointer")
                .on("mouseover", function(event, d) {
                    // Highlight effect
                    d3.select(this).select(".show-bar")
                        .transition()
                        .duration(100)
                        .attr("opacity", 1)
                        .attr("stroke", "#fff")
                        .attr("stroke-width", 2);
                    
                    showTooltip(event, d.title, d);
                })
                .on("mouseout", function(event, d) {
                    // Remove highlight
                    d3.select(this).select(".show-bar")
                        .transition()
                        .duration(100)
                        .attr("opacity", 0.8)
                        .attr("stroke", "none");
                    
                    hideTooltip();
                });
        }

        function playAnimation() {
            if (animationState.isPlaying) return;
            
            animationState.isPlaying = true;
            updateControlButtons();
            
            animationState.interval = setInterval(() => {
                if (animationState.currentDateIndex >= animationState.uniqueDates.length - 1) {
                    stopAnimation();
                    return;
                }
                
                animationState.currentDateIndex++;
                drawBumpChartFrame(
                    animationState.currentDateIndex,
                    d3.scaleLinear().domain([1, 10]).range([0, config.height - config.margin.top - config.margin.bottom]),
                    d3.scaleOrdinal(d3.schemeCategory10),
                    config.width - config.margin.left - config.margin.right,
                    config.height - config.margin.top - config.margin.bottom
                );
            }, animationState.speed);
        }

        function pauseAnimation() {
            animationState.isPlaying = false;
            if (animationState.interval) {
                clearInterval(animationState.interval);
                animationState.interval = null;
            }
            updateControlButtons();
        }

        function stopAnimation() {
            pauseAnimation();
            animationState.currentDateIndex = 0;
            drawBumpChartFrame(
                0,
                d3.scaleLinear().domain([1, 10]).range([0, config.height - config.margin.top - config.margin.bottom]),
                d3.scaleOrdinal(d3.schemeCategory10),
                config.width - config.margin.left - config.margin.right,
                config.height - config.margin.top - config.margin.bottom
            );
        }

        function resetAnimation() {
            stopAnimation();
        }

        function updateControlButtons() {
            d3.select("#play-btn")
                .style("background-color", animationState.isPlaying ? "#666" : "#e50914")
                .property("disabled", animationState.isPlaying);
            
            d3.select("#pause-btn")
                .style("background-color", !animationState.isPlaying ? "#666" : "#e50914")
                .property("disabled", !animationState.isPlaying);
        }

        function drawLevel2() {
            updateLevelIndicator(2, "Level 2: Top 10 Most Persistent Shows");
            updateChartTitle("Hall of Fame: Most Days in Netflix Top 10");

            const chartArea = svg.select(".chart-area");
            chartArea.selectAll("*").remove(); // Clear previous content

            // Remove animation controls for Level 2
            d3.select("#animation-controls").remove();

            if (processedData.length === 0) {
                showError("No valid data to display");
                return;
            }

            // Calculate days in top 10 for each show
            const showStats = calculateShowPersistence();
            
            // Get top 10 most persistent shows
            const top10Shows = showStats
                .sort((a, b) => b.daysInTop10 - a.daysInTop10)
                .slice(0, 10);

            console.log("Top 10 Most Persistent Shows:", top10Shows);

            // Set up scales
            const chartWidth = config.width - config.margin.left - config.margin.right;
            const chartHeight = config.height - config.margin.top - config.margin.bottom;
            
            // Create a bar chart showing persistence stats
            const xScale = d3.scaleLinear()
                .domain([0, d3.max(top10Shows, d => d.daysInTop10)])
                .range([0, chartWidth * 0.6]);

            const yScale = d3.scaleBand()
                .domain(top10Shows.map(d => d.title))
                .range([0, chartHeight])
                .padding(0.1);

            // Create color scale based on content type
            const colorScale = d3.scaleOrdinal()
                .domain(['Movie', 'TV Show', 'Unknown'])
                .range(['#e50914', '#00d4ff', '#999999']);

            // Add legend
            addLevel2Legend(chartArea, chartWidth, top10Shows, colorScale);

            // Add X axis
            chartArea.append("g")
                .attr("class", "x-axis")
                .attr("transform", `translate(0, ${chartHeight})`)
                .call(d3.axisBottom(xScale))
                .selectAll("text")
                .style("fill", "#ccc");

            // Add Y axis labels
            chartArea.append("g")
                .attr("class", "y-axis")
                .selectAll(".y-label")
                .data(top10Shows)
                .enter()
                .append("text")
                .attr("class", "y-label")
                .attr("x", -10)
                .attr("y", d => yScale(d.title) + yScale.bandwidth() / 2)
                .attr("dy", "0.35em")
                .attr("text-anchor", "end")
                .style("fill", "#fff")
                .style("font-size", "12px")
                .text(d => d.title.length > 20 ? d.title.substring(0, 20) + "..." : d.title);

            // Add bars
            const bars = chartArea.selectAll(".persistence-bar")
                .data(top10Shows)
                .enter()
                .append("rect")
                .attr("class", "persistence-bar")
                .attr("x", 0)
                .attr("y", d => yScale(d.title))
                .attr("width", 0)
                .attr("height", yScale.bandwidth())
                .attr("fill", d => colorScale(d.type))
                .attr("opacity", 0.8);

            // Animate bars
            bars.transition()
                .duration(1000)
                .delay((d, i) => i * 100)
                .attr("width", d => xScale(d.daysInTop10));

            // Add value labels
            const labels = chartArea.selectAll(".value-label")
                .data(top10Shows)
                .enter()
                .append("text")
                .attr("class", "value-label")
                .attr("x", d => xScale(d.daysInTop10) + 10)
                .attr("y", d => yScale(d.title) + yScale.bandwidth() / 2)
                .attr("dy", "0.35em")
                .style("fill", "#fff")
                .style("font-size", "11px")
                .style("opacity", 0)
                .text(d => `${d.daysInTop10} days (best: #${d.bestRank})`);

            // Animate labels
            labels.transition()
                .duration(1000)
                .delay((d, i) => i * 100 + 500)
                .style("opacity", 1);

            // Add axis labels
            chartArea.append("text")
                .attr("class", "axis-label")
                .attr("x", chartWidth / 2)
                .attr("y", chartHeight + 50)
                .attr("text-anchor", "middle")
                .style("fill", "#fff")
                .style("font-size", "14px")
                .text("Days in Top 10");

            // Add interactions
            bars.style("cursor", "pointer")
                .on("click", function(event, d) {
                    // Navigate to Level 3 with this show
                    goToLevel3(d.title);
                })
                .on("mouseover", function(event, d) {
                    d3.select(this)
                        .transition()
                        .duration(100)
                        .attr("opacity", 1)
                        .attr("stroke", "#fff")
                        .attr("stroke-width", 2);
                    
                    showLevel2BarTooltip(event, d);
                })
                .on("mouseout", function(event, d) {
                    d3.select(this)
                        .transition()
                        .duration(100)
                        .attr("opacity", 0.8)
                        .attr("stroke", "none");
                    
                    hideTooltip();
                });
        }

        // NEW: Level 3 - Show Lifecycle Visualization
        function drawLevel3(selectedShow = null) {
            updateLevelIndicator(3, "Level 3: Show Lifecycle Analysis");
            updateChartTitle("The Rise and Fall: Ranking Trajectory After Release");

            const chartArea = svg.select(".chart-area");
            chartArea.selectAll("*").remove();

            // Remove animation controls
            d3.select("#animation-controls").remove();

            if (processedData.length === 0) {
                showError("No valid data to display");
                return;
            }

            // Create show selector if no show is selected
            if (!selectedShow) {
                selectedShow = createShowSelector();
            }

            // Get lifecycle data for selected show
            const lifecycleData = getShowLifecycleData(selectedShow);
            
            if (lifecycleData.length === 0) {
                showError("No data found for the selected show");
                return;
            }

            console.log("Lifecycle data for", selectedShow, ":", lifecycleData);

            // Set up scales
            const chartWidth = config.width - config.margin.left - config.margin.right;
            const chartHeight = config.height - config.margin.top - config.margin.bottom;

            // Get the show's release date
            const showData = processedData.find(d => d.title === selectedShow);
            const releaseDate = showData ? showData.releaseDate : null;

            // Time scale - extend beyond the data range to show the full story
            const timeExtent = d3.extent(lifecycleData, d => d.date);
            const xScale = d3.scaleTime()
                .domain([
                    d3.timeDay.offset(timeExtent[0], -7), // Start 7 days before first appearance
                    d3.timeDay.offset(timeExtent[1], 30)  // End 30 days after last appearance
                ])
                .range([0, chartWidth]);

            // Rank scale (inverted so rank 1 is at the top)
            const yScale = d3.scaleLinear()
                .domain([1, 15]) // Extended to show "out of top 10"
                .range([0, chartHeight]);

            // Add axes
            const xAxis = d3.axisBottom(xScale)
                .tickFormat(d3.timeFormat("%b %d"));
            
            const yAxis = d3.axisLeft(yScale)
                .tickValues([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15])
                .tickFormat(d => d === 15 ? "Out of Top 10" : `#${d}`);

            chartArea.append("g")
                .attr("class", "x-axis")
                .attr("transform", `translate(0, ${chartHeight})`)
                .call(xAxis)
                .selectAll("text")
                .style("fill", "#ccc")
                .style("font-size", "11px");

            chartArea.append("g")
                .attr("class", "y-axis")
                .call(yAxis)
                .selectAll("text")
                .style("fill", "#ccc")
                .style("font-size", "11px");

            // Add axis labels
            chartArea.append("text")
                .attr("class", "axis-label")
                .attr("x", chartWidth / 2)
                .attr("y", chartHeight + 50)
                .attr("text-anchor", "middle")
                .style("fill", "#fff")
                .style("font-size", "14px")
                .text("Date");

            chartArea.append("text")
                .attr("class", "axis-label")
                .attr("transform", "rotate(-90)")
                .attr("y", -50)
                .attr("x", -chartHeight / 2)
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .style("fill", "#fff")
                .style("font-size", "14px")
                .text("Ranking");

            // Add background shading for "out of top 10" area
            chartArea.append("rect")
                .attr("class", "out-of-top10-bg")
                .attr("x", 0)
                .attr("y", yScale(10.5))
                .attr("width", chartWidth)
                .attr("height", yScale(15) - yScale(10.5))
                .attr("fill", "#333")
                .attr("opacity", 0.3);

            chartArea.append("text")
                .attr("x", chartWidth - 10)
                .attr("y", yScale(12.5))
                .attr("text-anchor", "end")
                .style("fill", "#666")
                .style("font-size", "12px")
                .text("Out of Top 10");

            // Add release date line if available
            if (releaseDate && releaseDate >= xScale.domain()[0] && releaseDate <= xScale.domain()[1]) {
                chartArea.append("line")
                    .attr("class", "release-line")
                    .attr("x1", xScale(releaseDate))
                    .attr("x2", xScale(releaseDate))
                    .attr("y1", 0)
                    .attr("y2", chartHeight)
                    .style("stroke", "#00d4ff")
                    .style("stroke-width", 2)
                    .style("stroke-dasharray", "5,5");

                chartArea.append("text")
                    .attr("x", xScale(releaseDate) + 5)
                    .attr("y", 20)
                    .style("fill", "#00d4ff")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .text("Release Date");
            }

            // Create line generator
            const line = d3.line()
                .x(d => xScale(d.date))
                .y(d => yScale(d.rank))
                .curve(d3.curveMonotoneX);

            // Draw the lifecycle line
            const path = chartArea.append("path")
                .datum(lifecycleData)
                .attr("class", "lifecycle-line")
                .attr("d", line)
                .style("fill", "none")
                .style("stroke", "#e50914")
                .style("stroke-width", 3);

            // Animate the line drawing
            const totalLength = path.node().getTotalLength();
            path
                .attr("stroke-dasharray", totalLength + " " + totalLength)
                .attr("stroke-dashoffset", totalLength)
                .transition()
                .duration(2000)
                .ease(d3.easeLinear)
                .attr("stroke-dashoffset", 0);

            // Add data points
            const points = chartArea.selectAll(".lifecycle-point")
                .data(lifecycleData)
                .enter()
                .append("circle")
                .attr("class", "lifecycle-point")
                .attr("cx", d => xScale(d.date))
                .attr("cy", d => yScale(d.rank))
                .attr("r", 0)
                .style("fill", "#e50914")
                .style("stroke", "#fff")
                .style("stroke-width", 2);

            // Animate points appearing
            points.transition()
                .duration(2000)
                .delay((d, i) => i * 50)
                .attr("r", 4);

            // Add interactivity to points
            points
                .style("cursor", "pointer")
                .on("mouseover", function(event, d) {
                    d3.select(this)
                        .transition()
                        .duration(100)
                        .attr("r", 6)
                        .style("stroke-width", 3);
                    
                    showLifecycleTooltip(event, d, releaseDate);
                })
                .on("mouseout", function(event, d) {
                    d3.select(this)
                        .transition()
                        .duration(100)
                        .attr("r", 4)
                        .style("stroke-width", 2);
                    
                    hideTooltip();
                });

            // Add summary statistics
            addLifecycleSummary(chartArea, lifecycleData, releaseDate, chartWidth, selectedShow);
        }

        // Create show selector dropdown
        function createShowSelector() {
            // Remove existing selector
            d3.select("#show-selector").remove();

            // Get shows with enough data points for meaningful lifecycle analysis
            const showCounts = new Map();
            processedData.forEach(d => {
                if (!showCounts.has(d.title)) {
                    showCounts.set(d.title, {
                        title: d.title,
                        count: 0,
                        hasReleaseDate: d.releaseDate !== null
                    });
                }
                showCounts.get(d.title).count++;
            });

            // Filter shows with at least 5 data points and sort by count
            const viableShows = Array.from(showCounts.values())
                .filter(s => s.count >= 5)
                .sort((a, b) => b.count - a.count)
                .slice(0, 30); // Top 30 shows with most data

            const selectorDiv = d3.select("#visualization")
                .insert("div", "svg")
                .attr("id", "show-selector")
                .attr("class", "show-selector");

            selectorDiv.append("label")
                .style("color", "#fff")
                .style("font-weight", "bold")
                .text("Select a show to analyze: ");

            const select = selectorDiv.append("select")
                .attr("id", "show-select")
                .style("background-color", "#2a2a2a")
                .style("color", "white")
                .style("border", "1px solid #666")
                .style("padding", "8px 12px")
                .style("border-radius", "4px")
                .style("font-size", "14px")
                .on("change", function() {
                    const selectedShow = this.value;
                    drawLevel3(selectedShow);
                });

            select.selectAll("option")
                .data(viableShows)
                .enter()
                .append("option")
                .attr("value", d => d.title)
                .text(d => `${d.title} (${d.count} days)${d.hasReleaseDate ? ' ★' : ''}`);

            return viableShows[0].title; // Return first show as default
        }

        // Get lifecycle data for a specific show
        function getShowLifecycleData(showTitle) {
            const showData = processedData
                .filter(d => d.title === showTitle)
                .sort((a, b) => a.date - b.date);

            // If we have gaps in the data, we need to interpolate "out of top 10" periods
            const lifecycleData = [];
            const allDates = [...new Set(processedData.map(d => d.date))].sort((a, b) => a - b);
            
            let currentShowData = [...showData];
            let dataIndex = 0;

            // Track the show's journey including out-of-top-10 periods
            for (let i = 0; i < allDates.length; i++) {
                const currentDate = allDates[i];
                
                // Check if show appears in top 10 on this date
                const dayEntry = currentShowData[dataIndex];
                
                if (dayEntry && dayEntry.date.getTime() === currentDate.getTime()) {
                    // Show is in top 10
                    lifecycleData.push({
                        date: currentDate,
                        rank: dayEntry.rank,
                        inTop10: true,
                        type: dayEntry.type,
                        releaseDate: dayEntry.releaseDate
                    });
                    dataIndex++;
                } else if (lifecycleData.length > 0 && dataIndex < currentShowData.length) {
                    // Show is not in top 10 but we've seen it before and will see it again
                    // Add "out of top 10" point periodically to show gaps
                    if (i % 7 === 0) { // Add a point every 7 days when out of top 10
                        lifecycleData.push({
                            date: currentDate,
                            rank: 15, // Use 15 to represent "out of top 10"
                            inTop10: false,
                            type: showData[0].type,
                            releaseDate: showData[0].releaseDate
                        });
                    }
                }
            }

            return lifecycleData;
        }

        // Add lifecycle summary statistics
        function addLifecycleSummary(chartArea, lifecycleData, releaseDate, chartWidth, showTitle) {
            const summaryGroup = chartArea.append("g")
                .attr("class", "lifecycle-summary")
                .attr("transform", `translate(${chartWidth - 250}, 20)`);

            // Calculate summary stats
            const top10Data = lifecycleData.filter(d => d.inTop10);
            const totalDays = top10Data.length;
            const bestRank = d3.min(top10Data, d => d.rank) || "N/A";
            const averageRank = totalDays > 0 ? Math.round(d3.mean(top10Data, d => d.rank) * 10) / 10 : "N/A";
            
            // Calculate days since release (if available)
            let daysToTop10 = "N/A";
            if (releaseDate && top10Data.length > 0) {
                const firstTop10 = d3.min(top10Data, d => d.date);
                daysToTop10 = Math.round((firstTop10 - releaseDate) / (1000 * 60 * 60 * 24));
            }

            // Calculate staying power (consecutive days in top 10)
            let longestStreak = 0;
            let currentStreak = 0;
            const sortedDates = top10Data.map(d => d.date).sort((a, b) => a - b);
            
            for (let i = 0; i < sortedDates.length; i++) {
                if (i === 0) {
                    currentStreak = 1;
                } else {
                    const dayDiff = (sortedDates[i] - sortedDates[i-1]) / (1000 * 60 * 60 * 24);
                    if (dayDiff <= 1) {
                        currentStreak++;
                    } else {
                        longestStreak = Math.max(longestStreak, currentStreak);
                        currentStreak = 1;
                    }
                }
            }
            longestStreak = Math.max(longestStreak, currentStreak);

            // Add summary box
            summaryGroup.append("rect")
                .attr("x", -10)
                .attr("y", -10)
                .attr("width", 240)
                .attr("height", 150)
                .attr("fill", "#2a2a2a")
                .attr("stroke", "#e50914")
                .attr("stroke-width", 1)
                .attr("opacity", 0.9)
                .attr("rx", 5);

            // Add title
            summaryGroup.append("text")
                .attr("x", 5)
                .attr("y", 10)
                .style("fill", "#e50914")
                .style("font-size", "14px")
                .style("font-weight", "bold")
                .text("Show Analytics");

            const stats = [
                `Total days in Top 10: ${totalDays}`,
                `Best rank: #${bestRank}`,
                `Average rank: ${averageRank}`,
                `Longest streak: ${longestStreak} days`,
                `Days to reach Top 10: ${daysToTop10}`
            ];

            summaryGroup.selectAll(".stat-text")
                .data(stats)
                .enter()
                .append("text")
                .attr("class", "stat-text")
                .attr("x", 5)
                .attr("y", (d, i) => 30 + i * 18)
                .style("fill", "#fff")
                .style("font-size", "12px")
                .text(d => d);
        }

        // Enhanced tooltip for lifecycle visualization
        function showLifecycleTooltip(event, data, releaseDate) {
            tooltip.transition()
                .duration(200)
                .style("opacity", .9);

            let daysSinceRelease = "Unknown";
            if (releaseDate) {
                daysSinceRelease = Math.round((data.date - releaseDate) / (1000 * 60 * 60 * 24));
            }

            const tooltipContent = data.inTop10 ? 
                `<strong>Rank #${data.rank}</strong><br/>
                 Date: ${d3.timeFormat("%B %e, %Y")(data.date)}<br/>
                 Days since release: ${daysSinceRelease}<br/>
                 Status: In Top 10` :
                `<strong>Out of Top 10</strong><br/>
                 Date: ${d3.timeFormat("%B %e, %Y")(data.date)}<br/>
                 Days since release: ${daysSinceRelease}<br/>
                 Status: Not ranked`;
            
            tooltip.html(tooltipContent)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 28) + "px");
        }