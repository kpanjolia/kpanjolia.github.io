<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Netflix Top 10 During COVID</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Cambria Math', serif;
            margin: 0;
            padding: 20px;
            background-color: #0f0f0f;
            color: #ffffff;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #e50914;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            color: #999;
            font-size: 1.2em;
            margin-bottom: 40px;
        }

        .level-indicator {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.1em;
            color: #e50914;
        }

        #visualization {
            background-color: #1a1a1a;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .chart-title {
            text-align: center;
            font-size: 1.4em;
            margin-bottom: 20px;
            color: #fff;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #e50914;
            pointer-events: none;
            font-size: 12px;
            z-index: 1000;
        }

        .axis {
            font-size: 12px;
            fill: #ccc;
        }

        .axis-label {
            font-size: 14px;
            fill: #fff;
        }

        .loading {
            text-align: center;
            font-size: 1.2em;
            color: #999;
            margin: 50px 0;
        }

        .error {
            text-align: center;
            color: #e50914;
            font-size: 1.1em;
            margin: 50px 0;
        }

        .navigation {
            text-align: center;
            margin-top: 20px;
        }

        .nav-button {
            background-color: #e50914;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 0 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .nav-button:hover {
            background-color: #b20710;
        }

        .nav-button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }

        .nav-button.active {
            background-color: #b20710;
            box-shadow: 0 0 10px rgba(229, 9, 20, 0.5);
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Netflix Top 10 During COVID</h1>
        <p class="subtitle">Daily Rankings of Movies and TV Shows in the US from March 31st, 2020 to March 10th, 2022</p>

        <div class="level-indicator">
            <span id="current-level">Level 1: The Streaming Landscape</span>
        </div>
        
        <div id="visualization">
            <div class="chart-title" id="chart-title">Loading Netflix data...</div>
            <div class="loading" id="loading">Fetching data from repository...</div>
        </div>
  
        <div class="navigation">
            <button class="nav-button active" id="level1-btn" disabled>Level 1</button>
            <button class="nav-button" id="level2-btn" disabled>Level 2</button>
            <button class="nav-button" id="reset-btn" disabled>Reset to Overview</button>
        </div>
    </div>

    <script>
        const config = {
            width: 1000,
            height: 600,
            margin: { top: 40, right: 80, bottom: 80, left: 80 },
            dataPath: "./data/netflix_daily_top_10.csv"
        };

        let rawData = [];
        let processedData = [];
        let currentLevel = 1;
        let svg, tooltip;

        function init() {
            setupSVG();
            setupTooltip();
            loadData();
            setupNavigation();
        }

        function setupSVG() {
            const container = d3.select("#visualization");
            
            svg = container.append("svg")
                .attr("width", config.width)
                .attr("height", config.height)
                .style("display", "block")
                .style("margin", "0 auto");

            // group for main chart area
            svg.append("g")
                .attr("class", "chart-area")
                .attr("transform", `translate(${config.margin.left},${config.margin.top})`);
        }

        function setupTooltip() {
            tooltip = d3.select("body")
                .append("div")
                .attr("class", "tooltip")
                .style("opacity", 0);
        }

        // load and process data
        async function loadData() {
            try {
                const data = await d3.csv(config.dataPath);
                
                if (!data || data.length === 0) {
                    showError("No data found. Please check your data file path.");
                    return;
                }

                rawData = data;
                processedData = processData(data);
                
                hideLoading();
                drawLevel1();
                enableNavigation();
                
            } catch (error) {
                console.error("Error loading data:", error);
                showError(`Error loading data: ${error.message}. Make sure your CSV file is accessible at: ${config.dataPath}`);
            }
        }

        // Process raw CSV data
        function processData(data) {
            return data.map(d => ({
                date: d3.timeParse("%Y-%m-%d")(d["As of"]), 
                title: d["Title"],
                rank: +d["Rank"],
                type: d["Type"],
                releaseDate: d3.timeParse("%b %e, %Y")(d["Netflix Release Date"]),
            })); 
        }

        // Level 1: Overview visualization
        let animationState = {
            isPlaying: false,
            currentDateIndex: 0,
            interval: null,
            speed: 50, // milliseconds per frame
            uniqueDates: [],
            dateData: new Map()
        };

        // Level 1: Animated Bump Chart visualization
        function drawLevel1() {
            updateLevelIndicator(1, "Level 1: The Streaming Landscape");
            updateChartTitle("Animated Top 10 Rankings Over Time");

            const chartArea = svg.select(".chart-area");
            chartArea.selectAll("*").remove(); // Clear previous content

            if (processedData.length === 0) {
                showError("No valid data to display");
                return;
            }

            // Prepare data for animation
            prepareAnimationData();
            
            // Set up scales
            const chartWidth = config.width - config.margin.left - config.margin.right;
            const chartHeight = config.height - config.margin.top - config.margin.bottom;
            
            const yScale = d3.scaleLinear()
                .domain([1, 10])
                .range([0, chartHeight]);

            const colorScale = d3.scaleOrdinal()
            .domain(['Movie', 'TV Show', 'Unknown'])
            .range(['#e50914', '#00d4ff', '#999999']);

            const legend = chartArea.append("g")
                .attr("class", "legend")
                .attr("transform", `translate(${chartWidth - 150}, 20)`);

            const legendData = [
                { type: 'Movie', color: '#e50914' },
                { type: 'TV Show', color: '#00d4ff' },
                { type: 'Unknown', color: '#999999' }
            ];

            const legendItems = legend.selectAll(".legend-item")
                .data(legendData)
                .enter()
                .append("g")
                .attr("class", "legend-item")
                .attr("transform", (d, i) => `translate(0, ${i * 20})`);

            legendItems.append("rect")
                .attr("width", 12)
                .attr("height", 12)
                .attr("fill", d => d.color);

            legendItems.append("text")
                .attr("x", 18)
                .attr("y", 6)
                .attr("dy", "0.35em")
                .style("fill", "#fff")
                .style("font-size", "12px")
                .text(d => d.type);

            // Add ranking labels (1-10)
            chartArea.selectAll(".rank-label")
                .data([1,2,3,4,5,6,7,8,9,10])
                .enter()
                .append("text")
                .attr("class", "rank-label")
                .attr("x", -10)
                .attr("y", d => yScale(d) + 5)
                .attr("text-anchor", "end")
                .style("fill", "#999")
                .style("font-size", "12px")
                .text(d => d);

            // Add title "Rank" label
            chartArea.append("text")
                .attr("class", "axis-label")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - config.margin.left + 20)
                .attr("x", 0 - chartHeight / 2)
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .style("fill", "#fff")
                .text("Rank");

            // Create animation controls
            createAnimationControls();
            
            // Draw initial frame
            drawBumpChartFrame(0, yScale, colorScale, chartWidth, chartHeight);
        }

        function prepareAnimationData() {
            // Get unique dates sorted
            animationState.uniqueDates = [...new Set(processedData.map(d => d.date))]
                .sort((a, b) => a - b);

            // Group data by date
            animationState.dateData = d3.group(processedData, d => d.date.getTime());
            
            // Fill in missing rankings for smooth animation
            animationState.uniqueDates.forEach(date => {
                const dateKey = date.getTime();
                const dayData = animationState.dateData.get(dateKey) || [];
                
                // Ensure we have exactly 10 entries for each date
                const rankedData = [];
                for (let rank = 1; rank <= 10; rank++) {
                    const entry = dayData.find(d => d.rank === rank);
                    if (entry) {
                        rankedData.push(entry);
                    } else {
                        // Fill with placeholder if no show at this rank
                        rankedData.push({
                            date: date,
                            title: `Rank ${rank}`,
                            rank: rank,
                            isPlaceholder: true
                        });
                    }
                }
                animationState.dateData.set(dateKey, rankedData);
            });
        }

        function createAnimationControls() {
            // Remove existing controls
            d3.select("#animation-controls").remove();
            
            // Add animation controls before the chart
            const controlsDiv = d3.select("#visualization")
                .insert("div", "svg")
                .attr("id", "animation-controls")
                .style("text-align", "center")
                .style("margin-bottom", "20px");

            // Current date display
            controlsDiv.append("div")
                .attr("id", "current-date")
                .style("font-size", "18px")
                .style("color", "#e50914")
                .style("margin-bottom", "10px")
                .text("March 2020");

            // Control buttons
            const buttonGroup = controlsDiv.append("div")
                .attr("id", "button-group");

            buttonGroup.append("button")
                .attr("id", "play-btn")
                .attr("class", "control-button")
                .style("background-color", "#e50914")
                .style("color", "white")
                .style("border", "none")
                .style("padding", "8px 16px")
                .style("margin", "0 5px")
                .style("border-radius", "4px")
                .style("cursor", "pointer")
                .text("▶ Play")
                .on("click", playAnimation);

            buttonGroup.append("button")
                .attr("id", "pause-btn")
                .attr("class", "control-button")
                .style("background-color", "#666")
                .style("color", "white")
                .style("border", "none")
                .style("padding", "8px 16px")
                .style("margin", "0 5px")
                .style("border-radius", "4px")
                .style("cursor", "pointer")
                .text("⏸ Pause")
                .on("click", pauseAnimation);

            buttonGroup.append("button")
                .attr("id", "stop-btn")
                .attr("class", "control-button")
                .style("background-color", "#666")
                .style("color", "white")
                .style("border", "none")
                .style("padding", "8px 16px")
                .style("margin", "0 5px")
                .style("border-radius", "4px")
                .style("cursor", "pointer")
                .text("⏹ Stop")
                .on("click", stopAnimation);

            buttonGroup.append("button")
                .attr("id", "reset-btn-anim")
                .attr("class", "control-button")
                .style("background-color", "#666")
                .style("color", "white")
                .style("border", "none")
                .style("padding", "8px 16px")
                .style("margin", "0 5px")
                .style("border-radius", "4px")
                .style("cursor", "pointer")
                .text("⏮ Reset")
                .on("click", resetAnimation);
        }

        function drawBumpChartFrame(dateIndex, yScale, colorScale, chartWidth, chartHeight) {
            const currentDate = animationState.uniqueDates[dateIndex];
            const currentData = animationState.dateData.get(currentDate.getTime()) || [];
            
            // Update date display
            d3.select("#current-date")
                .text(d3.timeFormat("%B %Y")(currentDate));

            const chartArea = svg.select(".chart-area");
            
            // First, draw static ranking background stripes if not already drawn
            if (chartArea.selectAll(".rank-bg").empty()) {
                chartArea.selectAll(".rank-bg")
                    .data([1,2,3,4,5,6,7,8,9,10])
                    .enter()
                    .append("rect")
                    .attr("class", "rank-bg")
                    .attr("x", 0)
                    .attr("y", d => yScale(d))
                    .attr("width", chartWidth)
                    .attr("height", chartHeight / 10 - 2)
                    .attr("fill", (d, i) => i % 2 === 0 ? "#2a2a2a" : "#1f1f1f")
                    .attr("opacity", 0.3);
            }
            
            // Bind data to show elements using title as key for continuity
            const shows = chartArea.selectAll(".show-element")
                .data(currentData.filter(d => !d.isPlaceholder), d => d.title);

            // Enter new shows
            const showEnter = shows.enter()
                .append("g")
                .attr("class", "show-element")
                .attr("transform", d => `translate(0, ${yScale(d.rank)})`);

            // Add colored bars for new shows
            showEnter.append("rect")
                .attr("class", "show-bar")
                .attr("x", 0)
                .attr("y", 2)
                .attr("height", chartHeight / 10 - 4)
                .attr("width", 0) // Start with 0 width for smooth entry
                .attr("fill", d => colorScale(d.type))
                .attr("opacity", 0.8)
                .transition()
                .duration(300)
                .attr("width", Math.max(100, chartWidth * 0.7));

            // Add title text for new shows
            showEnter.append("text")
                .attr("class", "show-title")
                .attr("x", 10)
                .attr("y", (chartHeight / 10) / 2)
                .attr("dy", "0.35em")
                .style("fill", "white")
                .style("font-size", "14px")
                .style("font-weight", "bold")
                .style("opacity", 0)
                .text(d => d.title.length > 30 ? d.title.substring(0, 30) + "..." : d.title)
                .transition()
                .duration(300)
                .style("opacity", 1);

            // Add rank number for new shows
            showEnter.append("text")
                .attr("class", "show-rank")
                .attr("x", chartWidth - 10)
                .attr("y", (chartHeight / 10) / 2)
                .attr("text-anchor", "end")
                .attr("dy", "0.35em")
                .style("fill", "#999")
                .style("font-size", "12px")
                .style("opacity", 0)
                .text(d => `#${d.rank}`)
                .transition()
                .duration(300)
                .style("opacity", 1);

            // Update existing shows - this is the key part for movement
            const showUpdate = showEnter.merge(shows);

            // Animate position changes - this creates the racing effect
            showUpdate.transition()
                .duration(animationState.isPlaying ? animationState.speed * 0.8 : 0)
                .ease(d3.easeLinear)
                .attr("transform", d => `translate(0, ${yScale(d.rank)})`);

            // Update rank text
            showUpdate.select(".show-rank")
                .transition()
                .duration(animationState.isPlaying ? animationState.speed * 0.4 : 0)
                .tween("text", function(d) {
                    const currentText = d3.select(this).text();
                    const currentRank = parseInt(currentText.replace('#', '')) || d.rank;
                    const interpolate = d3.interpolateNumber(currentRank, d.rank);
                    return function(t) {
                        d3.select(this).text(`#${Math.round(interpolate(t))}`);
                    };
                });

            // Update bar colors (in case show changes)
            showUpdate.select(".show-bar")
                .transition()
                .duration(animationState.isPlaying ? animationState.speed * 0.4 : 0)
                .attr("fill", d => colorScale(d.type));

            // Handle exiting shows (fade out)
            shows.exit()
                .transition()
                .duration(300)
                .style("opacity", 0)
                .remove();

            // Add interaction to show elements
            showUpdate
                .style("cursor", "pointer")
                .on("click", function(event, d) {
                    pauseAnimation();
                })
                .on("mouseover", function(event, d) {
                    // Highlight effect
                    d3.select(this).select(".show-bar")
                        .transition()
                        .duration(100)
                        .attr("opacity", 1)
                        .attr("stroke", "#fff")
                        .attr("stroke-width", 2);
                    
                    showTooltip(event, d.title, d);
                })
                .on("mouseout", function(event, d) {
                    // Remove highlight
                    d3.select(this).select(".show-bar")
                        .transition()
                        .duration(100)
                        .attr("opacity", 0.8)
                        .attr("stroke", "none");
                    
                    hideTooltip();
                });
        }

        function playAnimation() {
            if (animationState.isPlaying) return;
            
            animationState.isPlaying = true;
            updateControlButtons();
            
            animationState.interval = setInterval(() => {
                if (animationState.currentDateIndex >= animationState.uniqueDates.length - 1) {
                    stopAnimation();
                    return;
                }
                
                animationState.currentDateIndex++;
                drawBumpChartFrame(
                    animationState.currentDateIndex,
                    d3.scaleLinear().domain([1, 10]).range([0, config.height - config.margin.top - config.margin.bottom]),
                    d3.scaleOrdinal(d3.schemeCategory10),
                    config.width - config.margin.left - config.margin.right,
                    config.height - config.margin.top - config.margin.bottom
                );
            }, animationState.speed);
        }

        function pauseAnimation() {
            animationState.isPlaying = false;
            if (animationState.interval) {
                clearInterval(animationState.interval);
                animationState.interval = null;
            }
            updateControlButtons();
        }

        function stopAnimation() {
            pauseAnimation();
            animationState.currentDateIndex = 0;
            drawBumpChartFrame(
                0,
                d3.scaleLinear().domain([1, 10]).range([0, config.height - config.margin.top - config.margin.bottom]),
                d3.scaleOrdinal(d3.schemeCategory10),
                config.width - config.margin.left - config.margin.right,
                config.height - config.margin.top - config.margin.bottom
            );
        }

        function resetAnimation() {
            stopAnimation();
        }

        function updateControlButtons() {
            d3.select("#play-btn")
                .style("background-color", animationState.isPlaying ? "#666" : "#e50914")
                .property("disabled", animationState.isPlaying);
            
            d3.select("#pause-btn")
                .style("background-color", !animationState.isPlaying ? "#666" : "#e50914")
                .property("disabled", !animationState.isPlaying);
        }

        function drawLevel2() {
            updateLevelIndicator(2, "Level 2: Top 10 Most Persistent Shows");
            updateChartTitle("Hall of Fame: Most Days in Netflix Top 10");

            const chartArea = svg.select(".chart-area");
            chartArea.selectAll("*").remove(); // Clear previous content

            // Remove animation controls for Level 2
            d3.select("#animation-controls").remove();

            if (processedData.length === 0) {
                showError("No valid data to display");
                return;
            }

            // Calculate days in top 10 for each show
            const showStats = calculateShowPersistence();
            
            // Get top 10 most persistent shows
            const top10Shows = showStats
                .sort((a, b) => b.daysInTop10 - a.daysInTop10)
                .slice(0, 10);

            console.log("Top 10 Most Persistent Shows:", top10Shows);

            // Set up scales
            const chartWidth = config.width - config.margin.left - config.margin.right;
            const chartHeight = config.height - config.margin.top - config.margin.bottom;
            
            // Create a bar chart showing persistence stats
            const xScale = d3.scaleLinear()
                .domain([0, d3.max(top10Shows, d => d.daysInTop10)])
                .range([0, chartWidth * 0.6]);

            const yScale = d3.scaleBand()
                .domain(top10Shows.map(d => d.title))
                .range([0, chartHeight])
                .padding(0.1);

            // Create color scale based on content type
            const colorScale = d3.scaleOrdinal()
                .domain(['Movie', 'TV Show', 'Unknown'])
                .range(['#e50914', '#00d4ff', '#999999']);

            // Add legend
            addLevel2Legend(chartArea, chartWidth, top10Shows, colorScale);

            // Add X axis
            chartArea.append("g")
                .attr("class", "x-axis")
                .attr("transform", `translate(0, ${chartHeight})`)
                .call(d3.axisBottom(xScale))
                .selectAll("text")
                .style("fill", "#ccc");

            // Add Y axis labels
            chartArea.append("g")
                .attr("class", "y-axis")
                .selectAll(".y-label")
                .data(top10Shows)
                .enter()
                .append("text")
                .attr("class", "y-label")
                .attr("x", -10)
                .attr("y", d => yScale(d.title) + yScale.bandwidth() / 2)
                .attr("dy", "0.35em")
                .attr("text-anchor", "end")
                .style("fill", "#fff")
                .style("font-size", "12px")
                .text(d => d.title.length > 20 ? d.title.substring(0, 20) + "..." : d.title);

            // Add bars
            const bars = chartArea.selectAll(".persistence-bar")
                .data(top10Shows)
                .enter()
                .append("rect")
                .attr("class", "persistence-bar")
                .attr("x", 0)
                .attr("y", d => yScale(d.title))
                .attr("width", 0)
                .attr("height", yScale.bandwidth())
                .attr("fill", d => colorScale(d.type))
                .attr("opacity", 0.8);

            // Animate bars
            bars.transition()
                .duration(1000)
                .delay((d, i) => i * 100)
                .attr("width", d => xScale(d.daysInTop10));

            // Add value labels
            const labels = chartArea.selectAll(".value-label")
                .data(top10Shows)
                .enter()
                .append("text")
                .attr("class", "value-label")
                .attr("x", d => xScale(d.daysInTop10) + 10)
                .attr("y", d => yScale(d.title) + yScale.bandwidth() / 2)
                .attr("dy", "0.35em")
                .style("fill", "#fff")
                .style("font-size", "11px")
                .style("opacity", 0)
                .text(d => `${d.daysInTop10} days (best: #${d.bestRank})`);

            // Animate labels
            labels.transition()
                .duration(1000)
                .delay((d, i) => i * 100 + 500)
                .style("opacity", 1);

            // Add axis labels
            chartArea.append("text")
                .attr("class", "axis-label")
                .attr("x", chartWidth / 2)
                .attr("y", chartHeight + 50)
                .attr("text-anchor", "middle")
                .style("fill", "#fff")
                .style("font-size", "14px")
                .text("Days in Top 10");

            // Add interactions
            bars.style("cursor", "pointer")
                .on("mouseover", function(event, d) {
                    d3.select(this)
                        .transition()
                        .duration(100)
                        .attr("opacity", 1)
                        .attr("stroke", "#fff")
                        .attr("stroke-width", 2);
                    
                    showLevel2BarTooltip(event, d);
                })
                .on("mouseout", function(event, d) {
                    d3.select(this)
                        .transition()
                        .duration(100)
                        .attr("opacity", 0.8)
                        .attr("stroke", "none");
                    
                    hideTooltip();
                });
        }

        // Calculate show persistence statistics
        function calculateShowPersistence() {
            const showCounts = new Map();
            
            processedData.forEach(d => {
                if (!showCounts.has(d.title)) {
                    showCounts.set(d.title, {
                        title: d.title,
                        type: d.type,
                        category: d.category,
                        daysInTop10: 0,
                        appearances: [],
                        bestRank: 10,
                        averageRank: 0
                    });
                }
                
                const show = showCounts.get(d.title);
                show.daysInTop10++;
                show.appearances.push({
                    date: d.date,
                    rank: d.rank
                });
                show.bestRank = Math.min(show.bestRank, d.rank);
            });

            // Calculate average ranks
            showCounts.forEach(show => {
                const totalRank = show.appearances.reduce((sum, app) => sum + app.rank, 0);
                show.averageRank = Math.round(totalRank / show.appearances.length * 10) / 10;
            });

            return Array.from(showCounts.values());
        }

        // Prepare animation data specifically for Level 2
        function prepareLevel2AnimationData(filteredData, top10Shows) {
            // Get unique dates sorted
            animationState.uniqueDates = [...new Set(filteredData.map(d => d.date))]
                .sort((a, b) => a - b);

            // Group filtered data by date
            animationState.dateData = d3.group(filteredData, d => d.date.getTime());
            
            // For Level 2, we only show data when the top 10 persistent shows appear
            // No need to fill missing rankings since we're only tracking specific shows
        }

        // Add legend with persistence stats - simplified for bar chart
        function addLevel2Legend(chartArea, chartWidth, top10Shows, colorScale) {
            const legend = chartArea.append("g")
                .attr("class", "level2-legend")
                .attr("transform", `translate(${chartWidth - 180}, 20)`);

            // Title for legend
            legend.append("text")
                .attr("x", 0)
                .attr("y", -10)
                .style("fill", "#e50914")
                .style("font-size", "14px")
                .style("font-weight", "bold")
                .text("Content Type");

            // Show legend for content types
            const legendData = [
                { type: 'Movie', color: '#e50914' },
                { type: 'TV Show', color: '#00d4ff' },
                { type: 'Unknown', color: '#999999' }
            ];

            const legendItems = legend.selectAll(".legend-item")
                .data(legendData)
                .enter()
                .append("g")
                .attr("class", "legend-item")
                .attr("transform", (d, i) => `translate(0, ${i * 20 + 10})`);

            legendItems.append("rect")
                .attr("width", 12)
                .attr("height", 12)
                .attr("fill", d => d.color);

            legendItems.append("text")
                .attr("x", 18)
                .attr("y", 6)
                .attr("dy", "0.35em")
                .style("fill", "#fff")
                .style("font-size", "12px")
                .text(d => d.type);
        }

        // Draw Level 2 bump chart frame
        function drawLevel2BumpChartFrame(dateIndex, yScale, colorScale, chartWidth, chartHeight) {
            if (dateIndex >= animationState.uniqueDates.length) {
                return;
            }

            const currentDate = animationState.uniqueDates[dateIndex];
            const currentData = animationState.dateData.get(currentDate.getTime()) || [];
            
            // Update date display
            d3.select("#current-date")
                .text(d3.timeFormat("%B %Y")(currentDate));

            const chartArea = svg.select(".chart-area");
            
            // First, draw static ranking background stripes if not already drawn
            if (chartArea.selectAll(".rank-bg").empty()) {
                chartArea.selectAll(".rank-bg")
                    .data([1,2,3,4,5,6,7,8,9,10])
                    .enter()
                    .append("rect")
                    .attr("class", "rank-bg")
                    .attr("x", 0)
                    .attr("y", d => yScale(d))
                    .attr("width", chartWidth)
                    .attr("height", chartHeight / 10 - 2)
                    .attr("fill", (d, i) => i % 2 === 0 ? "#2a2a2a" : "#1f1f1f")
                    .attr("opacity", 0.3);
            }
            
            // Bind data to show elements using title as key for continuity
            const shows = chartArea.selectAll(".show-element")
                .data(currentData, d => d.title);

            // Enter new shows
            const showEnter = shows.enter()
                .append("g")
                .attr("class", "show-element")
                .attr("transform", d => `translate(0, ${yScale(d.rank)})`);

            // Add colored bars for new shows
            showEnter.append("rect")
                .attr("class", "show-bar")
                .attr("x", 0)
                .attr("y", 2)
                .attr("height", chartHeight / 10 - 4)
                .attr("width", 0) // Start with 0 width for smooth entry
                .attr("fill", d => colorScale(d.type))
                .attr("opacity", 0.8)
                .transition()
                .duration(300)
                .attr("width", Math.max(100, chartWidth * 0.7));

            // Add title text for new shows
            showEnter.append("text")
                .attr("class", "show-title")
                .attr("x", 10)
                .attr("y", (chartHeight / 10) / 2)
                .attr("dy", "0.35em")
                .style("fill", "white")
                .style("font-size", "14px")
                .style("font-weight", "bold")
                .style("opacity", 0)
                .text(d => d.title.length > 30 ? d.title.substring(0, 30) + "..." : d.title)
                .transition()
                .duration(300)
                .style("opacity", 1);

            // Add rank number for new shows
            showEnter.append("text")
                .attr("class", "show-rank")
                .attr("x", chartWidth - 10)
                .attr("y", (chartHeight / 10) / 2)
                .attr("text-anchor", "end")
                .attr("dy", "0.35em")
                .style("fill", "#999")
                .style("font-size", "12px")
                .style("opacity", 0)
                .text(d => `#${d.rank}`)
                .transition()
                .duration(300)
                .style("opacity", 1);

            // Update existing shows - this is the key part for movement
            const showUpdate = showEnter.merge(shows);

            // Animate position changes - this creates the racing effect
            showUpdate.transition()
                .duration(animationState.isPlaying ? animationState.speed * 0.8 : 0)
                .ease(d3.easeLinear)
                .attr("transform", d => `translate(0, ${yScale(d.rank)})`);

            // Update rank text
            showUpdate.select(".show-rank")
                .transition()
                .duration(animationState.isPlaying ? animationState.speed * 0.4 : 0)
                .tween("text", function(d) {
                    const currentText = d3.select(this).text();
                    const currentRank = parseInt(currentText.replace('#', '')) || d.rank;
                    const interpolate = d3.interpolateNumber(currentRank, d.rank);
                    return function(t) {
                        d3.select(this).text(`#${Math.round(interpolate(t))}`);
                    };
                });

            // Update bar colors (in case show changes)
            showUpdate.select(".show-bar")
                .transition()
                .duration(animationState.isPlaying ? animationState.speed * 0.4 : 0)
                .attr("fill", d => colorScale(d.type));

            // Handle exiting shows (fade out)
            shows.exit()
                .transition()
                .duration(300)
                .style("opacity", 0)
                .remove();

            // Add interaction to show elements
            showUpdate
                .style("cursor", "pointer")
                .on("click", function(event, d) {
                    pauseAnimation();
                    // Could drill down to Level 3 here
                    console.log("Clicked on persistent show:", d.title);
                })
                .on("mouseover", function(event, d) {
                    // Highlight effect
                    d3.select(this).select(".show-bar")
                        .transition()
                        .duration(100)
                        .attr("opacity", 1)
                        .attr("stroke", "#fff")
                        .attr("stroke-width", 2);
                    
                    showLevel2Tooltip(event, d);
                })
                .on("mouseout", function(event, d) {
                    // Remove highlight
                    d3.select(this).select(".show-bar")
                        .transition()
                        .duration(100)
                        .attr("opacity", 0.8)
                        .attr("stroke", "none");
                    
                    hideTooltip();
                });
        }

        // Enhanced tooltip for Level 2 bar chart
        function showLevel2BarTooltip(event, data) {
            tooltip.transition()
                .duration(200)
                .style("opacity", .9);
            
            const tooltipContent = 
                `<strong>${data.title}</strong><br/>
                 Type: ${data.type}<br/>
                 <strong>Persistence Stats:</strong><br/>
                 Total days in top 10: ${data.daysInTop10}<br/>
                 Best rank achieved: #${data.bestRank}<br/>
                 Average rank: ${data.averageRank}`;
            
            tooltip.html(tooltipContent)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 28) + "px");
        }

        // Utility functions
        function showTooltip(event, title, data) {
            tooltip.transition()
                .duration(200)
                .style("opacity", .9);
            
            const tooltipContent = data.isPlaceholder ? 
                `<strong>No data</strong>` :
                `<strong>${title}</strong><br/>
                 Rank: #${data.rank}<br/>
                 Type: ${data.type}<br/>
                 Date: ${d3.timeFormat("%B %e, %Y")(data.date)}<br/>
                 <em>Click to explore in detail</em>`;
            
            tooltip.html(tooltipContent)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 28) + "px");
        }

        function hideTooltip() {
            tooltip.transition()
                .duration(500)
                .style("opacity", 0);
        }

        function updateLevelIndicator(level, text) {
            d3.select("#current-level").text(text);
        }

        function updateChartTitle(title) {
            d3.select("#chart-title").text(title);
        }

        function hideLoading() {
            d3.select("#loading").style("display", "none");
        }

        function showError(message) {
            d3.select("#loading").remove();
            d3.select("#visualization").append("div")
                .attr("class", "error")
                .text(message);
        }

        // CHANGED: Updated navigation setup to use Level 1 and Level 2 buttons
        function setupNavigation() {
            d3.select("#level1-btn").on("click", goToLevel2);
            d3.select("#level2-btn").on("click", goToLevel1);
            d3.select("#reset-btn").on("click", resetToOverview);
        }

        function enableNavigation() {
            d3.select("#reset-btn").property("disabled", false);
            d3.select("#level1-btn").property("disabled", false);
            d3.select("#level2-btn").property("disabled", false);
            updateNavButtons();
        }

        // CHANGED: Updated navigation button states to show active level
        function updateNavButtons() {
            // Remove active class from all buttons
            d3.selectAll(".nav-button").classed("active", false);
            
            // Add active class to current level button
            if (currentLevel === 1) {
                d3.select("#level1-btn").classed("active", true);
            } else if (currentLevel === 2) {
                d3.select("#level2-btn").classed("active", true);
            }
        }

        // CHANGED: New function to go to Level 1
        function goToLevel1() {
            if (currentLevel !== 1) {
                currentLevel = 1;
                drawLevel1();
                updateNavButtons();
            }
        }

        // CHANGED: New function to go to Level 2
        function goToLevel2() {
            if (currentLevel !== 2) {
                currentLevel = 2;
                drawLevel2();
                updateNavButtons();
            }
        }

        function resetToOverview() {
            currentLevel = 1;
            drawLevel1();
            updateNavButtons();
        }

        // Make the visualization responsive
        function resizeVisualization() {
            const container = d3.select("#visualization");
            const containerWidth = parseInt(container.style("width"));
            
            if (containerWidth < config.width) {
                svg.attr("width", containerWidth)
                   .attr("height", (containerWidth / config.width) * config.height);
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            init();
            window.addEventListener('resize', resizeVisualization);
        });
    </script>
</body>
</html>